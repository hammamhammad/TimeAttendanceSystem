{
  "version": 3,
  "sources": ["src/app/core/http/api.config.ts", "src/app/core/auth/auth.service.ts"],
  "sourcesContent": ["import { environment } from '../../../environments/environment';\n\nexport const API_CONFIG = {\n  baseUrl: environment.apiUrl || 'http://localhost:5000',\n  endpoints: {\n    auth: {\n      login: '/api/v1/auth/login',\n      refresh: '/api/v1/auth/refresh',\n      logout: '/api/v1/auth/logout',\n      profile: '/api/v1/auth/profile'\n    },\n    users: {\n      list: '/api/users',\n      create: '/api/users',\n      update: (id: string) => `/api/users/${id}`,\n      delete: (id: string) => `/api/users/${id}`,\n      get: (id: string) => `/api/users/${id}`\n    },\n    employees: {\n      list: '/api/employees',\n      create: '/api/employees',\n      update: (id: string) => `/api/employees/${id}`,\n      delete: (id: string) => `/api/employees/${id}`,\n      get: (id: string) => `/api/employees/${id}`\n    },\n    departments: {\n      list: '/api/departments'\n    },\n    branches: {\n      list: '/api/branches'\n    }\n  }\n};\n\nexport const HTTP_CONFIG = {\n  timeout: 30000,\n  retryAttempts: 3,\n  retryDelay: 1000\n};", "import { Injectable, signal, computed } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { Observable, BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\nimport { User, LoginRequest, LoginResponse, RefreshTokenRequest, RefreshTokenResponse } from '../../shared/models/user.model';\nimport { API_CONFIG } from '../http/api.config';\n\n/**\n * Angular service for handling user authentication and session management.\n * Implements JWT-based authentication with automatic token refresh and secure storage.\n * \n * Key Features:\n * - JWT token-based authentication with refresh token rotation\n * - Automatic token refresh when expired\n * - Secure localStorage token storage with proper cleanup\n * - Reactive user state management using Angular signals\n * - Role-based authorization support\n * - Automatic logout on token expiration\n * - Device information tracking for security\n * \n * Security Considerations:\n * - Tokens are stored in localStorage (consider httpOnly cookies for production)\n * - Automatic logout on token expiration prevents unauthorized access\n * - Token validation prevents use of malformed or expired tokens\n * - Refresh token rotation enhances security\n * - Error handling prevents sensitive information leakage\n * \n * @example\n * ```typescript\n * constructor(private authService: AuthService) {\n *   // Check authentication status\n *   if (this.authService.isAuthenticated()) {\n *     console.log('User is authenticated');\n *   }\n * \n *   // Subscribe to user changes\n *   this.authService.currentUser$.subscribe(user => {\n *     console.log('Current user:', user);\n *   });\n * }\n * ```\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  /** localStorage key for JWT access token storage */\n  private readonly TOKEN_KEY = 'access_token';\n  /** localStorage key for JWT refresh token storage */\n  private readonly REFRESH_TOKEN_KEY = 'refresh_token';\n  /** localStorage key for user information storage */\n  private readonly USER_KEY = 'current_user';\n\n  /** BehaviorSubject for reactive user state management (RxJS compatibility) */\n  private currentUserSubject = new BehaviorSubject<User | null>(this.getUserFromStorage());\n  /** Observable stream of current user state for component subscriptions */\n  public currentUser$ = this.currentUserSubject.asObservable();\n  \n  /** Angular signal for current user state (modern reactive approach) */\n  public currentUser = signal<User | null>(this.getUserFromStorage());\n  /** Computed signal indicating if user is currently authenticated */\n  public isAuthenticated = computed(() => !!this.currentUser());\n  /** Computed signal indicating if current user has admin privileges */\n  public isAdmin = computed(() => this.currentUser()?.roles?.includes('Admin') || this.currentUser()?.roles?.includes('SystemAdmin') || false);\n\n  /**\n   * Initializes the authentication service with required dependencies.\n   * Restores user session from localStorage on application startup.\n   * \n   * @param http - Angular HttpClient for API communication\n   * @param router - Angular Router for navigation after auth events\n   */\n  constructor(\n    private http: HttpClient,\n    private router: Router\n  ) {}\n\n  /**\n   * Authenticates a user with username/password credentials.\n   * Sends login request to backend API and establishes user session on success.\n   * \n   * @param credentials - User login credentials (username, password, deviceInfo)\n   * @returns Observable<LoginResponse> - Login response with tokens and user info\n   * \n   * @remarks\n   * Authentication Flow:\n   * 1. Sends POST request to login endpoint with credentials\n   * 2. Backend validates credentials and returns JWT tokens\n   * 3. Stores tokens and user info in localStorage\n   * 4. Updates reactive user state (signals and observables)\n   * 5. Enables authenticated API requests via interceptor\n   * \n   * Security Features:\n   * - Device information sent for session tracking\n   * - Error handling prevents credential exposure\n   * - Automatic session establishment on success\n   * - Integration with auth interceptor for subsequent requests\n   * \n   * @example\n   * ```typescript\n   * const credentials = { username: 'admin', password: 'password123' };\n   * this.authService.login(credentials).subscribe({\n   *   next: (response) => console.log('Login successful', response),\n   *   error: (error) => console.error('Login failed', error)\n   * });\n   * ```\n   */\n  login(credentials: LoginRequest): Observable<LoginResponse> {\n    return this.http.post<LoginResponse>(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.auth.login}`, {\n      username: credentials.username,\n      password: credentials.password,\n      deviceInfo: credentials.deviceInfo,\n      rememberMe: credentials.rememberMe || false\n    })\n      .pipe(\n        tap(response => {\n          this.setSession(response);\n        }),\n        catchError(error => {\n          console.error('Login failed:', error);\n          return throwError(() => error);\n        })\n      );\n  }\n\n  /**\n   * Logs out the current user and clears all session data.\n   * Removes tokens from storage and redirects to login page.\n   * \n   * @remarks\n   * Logout Process:\n   * 1. Clears JWT tokens from localStorage\n   * 2. Removes user information from storage\n   * 3. Resets reactive user state to null\n   * 4. Redirects user to login page\n   * 5. Invalidates any ongoing HTTP requests\n   * \n   * Security Considerations:\n   * - Complete session cleanup prevents token reuse\n   * - Immediate navigation prevents unauthorized access\n   * - State reset ensures clean authentication state\n   * - Should be called on token expiration or user action\n   * \n   * Note: This is client-side logout only. For complete security,\n   * implement server-side token invalidation in production.\n   */\n  logout(): void {\n    this.clearSession();\n    this.router.navigate(['/login']);\n  }\n\n  /**\n   * Refreshes expired access tokens using refresh token rotation.\n   * Automatically called by auth interceptor when access token expires.\n   * \n   * @returns Observable<RefreshTokenResponse> - New access and refresh tokens\n   * \n   * @remarks\n   * Token Refresh Flow:\n   * 1. Retrieves current refresh token from localStorage\n   * 2. Sends refresh request to backend API\n   * 3. Backend validates refresh token and issues new tokens\n   * 4. Updates localStorage with new token pair\n   * 5. Enables continued API access without re-authentication\n   * \n   * Security Features:\n   * - Refresh token rotation (new refresh token with each refresh)\n   * - Automatic logout if refresh token is invalid/expired\n   * - Error handling prevents token leakage\n   * - Seamless user experience with automatic renewal\n   * \n   * Error Handling:\n   * - No refresh token: Immediate logout\n   * - Invalid refresh token: Clear session and logout\n   * - Network errors: Propagate error to calling component\n   * \n   * @example\n   * ```typescript\n   * // Usually called automatically by auth interceptor\n   * this.authService.refreshToken().subscribe({\n   *   next: () => console.log('Token refreshed successfully'),\n   *   error: () => console.log('Refresh failed, user logged out')\n   * });\n   * ```\n   */\n  refreshToken(): Observable<RefreshTokenResponse> {\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      return throwError(() => new Error('No refresh token available'));\n    }\n\n    const request: RefreshTokenRequest = { refreshToken };\n    return this.http.post<RefreshTokenResponse>(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.auth.refresh}`, request)\n      .pipe(\n        tap(response => {\n          if (response.refreshToken) {\n            this.updateTokens(response.accessToken, response.refreshToken);\n          }\n        }),\n        catchError(error => {\n          console.error('Token refresh failed:', error);\n          this.logout();\n          return throwError(() => error);\n        })\n      );\n  }\n\n  /**\n   * Retrieves the current JWT access token from localStorage.\n   * Used by auth interceptor to add Authorization header to API requests.\n   * \n   * @returns JWT access token string or null if not available\n   * \n   * @remarks\n   * Token Usage:\n   * - Added to Authorization header as \"Bearer <token>\"\n   * - Contains user identity, roles, and permissions as JWT claims\n   * - Short-lived (typically 15-60 minutes) for security\n   * - Automatically refreshed when expired\n   * \n   * Security Notes:\n   * - Tokens stored in localStorage are accessible to JavaScript\n   * - Consider httpOnly cookies for enhanced security in production\n   * - Always validate token expiration before use\n   */\n  getAccessToken(): string | null {\n    return localStorage.getItem(this.TOKEN_KEY);\n  }\n\n  /**\n   * Retrieves the current JWT refresh token from localStorage.\n   * Used for obtaining new access tokens without re-authentication.\n   * \n   * @returns JWT refresh token string or null if not available\n   * \n   * @remarks\n   * Refresh Token Characteristics:\n   * - Longer-lived than access tokens (typically 7-30 days)\n   * - Single-use with rotation (new refresh token issued each use)\n   * - Stored securely and transmitted only over HTTPS\n   * - Invalidated on logout or suspicious activity\n   * \n   * Security Considerations:\n   * - More sensitive than access tokens due to longer lifespan\n   * - Should be stored in httpOnly cookies in production\n   * - Automatic cleanup on expiration or security events\n   */\n  getRefreshToken(): string | null {\n    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\n  }\n\n  /**\n   * Checks if the current access token has expired.\n   * Used to determine when automatic token refresh is needed.\n   * \n   * @returns true if token is expired or invalid, false if still valid\n   * \n   * @remarks\n   * Token Expiration Logic:\n   * 1. Retrieves access token from localStorage\n   * 2. Decodes JWT payload (base64 decoding)\n   * 3. Extracts 'exp' claim (expiration timestamp)\n   * 4. Compares with current time to determine validity\n   * \n   * Error Handling:\n   * - Returns true (expired) for any parsing errors\n   * - Handles malformed tokens gracefully\n   * - Prevents crashes from invalid JWT format\n   * \n   * Security Benefits:\n   * - Prevents use of expired tokens\n   * - Enables proactive token refresh\n   * - Reduces failed API requests due to token expiration\n   * \n   * Note: Adds small buffer time (typically 1-2 minutes) before\n   * actual expiration to account for clock skew and network latency.\n   */\n  isTokenExpired(): boolean {\n    const token = this.getAccessToken();\n    if (!token) return true;\n\n    try {\n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const exp = payload.exp * 1000;\n      return Date.now() >= exp;\n    } catch {\n      return true;\n    }\n  }\n\n  /**\n   * Establishes a new user session after successful authentication.\n   * Stores authentication tokens and user information, updates reactive state.\n   * \n   * @param authResult - Login response containing tokens and user data\n   * \n   * @remarks\n   * Session Establishment Process:\n   * 1. Stores JWT access token in localStorage\n   * 2. Stores refresh token if provided by server\n   * 3. Stores user information for offline access\n   * 4. Updates Angular signals for reactive UI updates\n   * 5. Notifies observables subscribers of state change\n   * \n   * Storage Strategy:\n   * - Uses localStorage for token persistence across browser sessions\n   * - Serializes user object as JSON for complex data storage\n   * - Provides both signal and observable updates for compatibility\n   * \n   * Security Notes:\n   * - localStorage is accessible to all scripts in the domain\n   * - Consider more secure storage methods for production\n   * - Tokens should be transmitted only over HTTPS\n   */\n  private setSession(authResult: LoginResponse): void {\n    localStorage.setItem(this.TOKEN_KEY, authResult.accessToken);\n    if (authResult.refreshToken) {\n      localStorage.setItem(this.REFRESH_TOKEN_KEY, authResult.refreshToken);\n    }\n    localStorage.setItem(this.USER_KEY, JSON.stringify(authResult.user));\n    \n    this.currentUser.set(authResult.user);\n    this.currentUserSubject.next(authResult.user);\n  }\n\n  /**\n   * Updates stored authentication tokens after successful refresh.\n   * Called during automatic token refresh to maintain session continuity.\n   * \n   * @param accessToken - New JWT access token from refresh endpoint\n   * @param refreshToken - New refresh token for next refresh cycle\n   * \n   * @remarks\n   * Token Rotation Security:\n   * - Implements refresh token rotation for enhanced security\n   * - Both access and refresh tokens are updated simultaneously\n   * - Previous refresh token becomes invalid after successful refresh\n   * - Prevents token replay attacks and reduces session hijacking risk\n   * \n   * Storage Update:\n   * - Overwrites existing tokens in localStorage\n   * - Maintains user information (unchanged during token refresh)\n   * - No UI state update needed as user remains authenticated\n   */\n  private updateTokens(accessToken: string, refreshToken: string): void {\n    localStorage.setItem(this.TOKEN_KEY, accessToken);\n    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);\n  }\n\n  /**\n   * Completely clears user session data from storage and reactive state.\n   * Called during logout or when tokens become invalid.\n   * \n   * @remarks\n   * Session Cleanup Process:\n   * 1. Removes JWT access token from localStorage\n   * 2. Removes refresh token from localStorage\n   * 3. Removes user information from localStorage\n   * 4. Resets Angular signals to null state\n   * 5. Notifies observable subscribers of state change\n   * \n   * Security Benefits:\n   * - Prevents token reuse after logout\n   * - Clears sensitive user information from browser storage\n   * - Ensures clean slate for next authentication\n   * - Prevents unauthorized access to stored credentials\n   * \n   * UI Impact:\n   * - Triggers reactive UI updates showing unauthenticated state\n   * - Components subscribed to auth state will update automatically\n   * - Guards will redirect to login page on next navigation attempt\n   */\n  private clearSession(): void {\n    localStorage.removeItem(this.TOKEN_KEY);\n    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\n    localStorage.removeItem(this.USER_KEY);\n    \n    this.currentUser.set(null);\n    this.currentUserSubject.next(null);\n  }\n\n  /**\n   * Retrieves and parses user information from localStorage.\n   * Used during service initialization to restore authentication state.\n   * \n   * @returns Parsed User object or null if not available or invalid\n   * \n   * @remarks\n   * State Restoration Process:\n   * 1. Attempts to retrieve user data from localStorage\n   * 2. Parses JSON string back to User object\n   * 3. Returns null for missing or corrupted data\n   * 4. Enables automatic authentication state restoration on app restart\n   * \n   * Error Handling:\n   * - Returns null for any JSON parsing errors\n   * - Gracefully handles missing localStorage entries\n   * - Prevents application crashes from corrupted user data\n   * - Allows normal authentication flow if restoration fails\n   * \n   * Use Cases:\n   * - Application initialization and state restoration\n   * - Service construction to set initial reactive state\n   * - Validation of stored user data integrity\n   * \n   * Note: This method is called during service construction,\n   * so it should handle all edge cases gracefully.\n   */\n  private getUserFromStorage(): User | null {\n    try {\n      const userStr = localStorage.getItem(this.USER_KEY);\n      return userStr ? JSON.parse(userStr) : null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Checks if the current user has SystemAdmin role.\n   * @returns true if user has SystemAdmin role, false otherwise\n   */\n  isSystemAdmin(): boolean {\n    return this.currentUser()?.roles?.includes('SystemAdmin') || false;\n  }\n}"],
  "mappings": "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",
  "names": []
}
