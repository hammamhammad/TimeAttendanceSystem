{
  "version": 3,
  "sources": ["src/app/core/http/api.config.ts", "src/app/core/auth/auth.service.ts"],
  "sourcesContent": ["import { environment } from '../../../environments/environment';\r\n\r\nexport const API_CONFIG = {\r\n  baseUrl: environment.apiUrl || 'http://localhost:5000',\r\n  endpoints: {\r\n    auth: {\r\n      login: '/api/v1/auth/login',\r\n      refresh: '/api/v1/auth/refresh',\r\n      logout: '/api/v1/auth/logout',\r\n      profile: '/api/v1/auth/profile',\r\n      changePassword: '/api/v1/auth/change-password'\r\n    },\r\n    users: {\r\n      list: '/api/users',\r\n      create: '/api/users',\r\n      update: (id: string) => `/api/users/${id}`,\r\n      delete: (id: string) => `/api/users/${id}`,\r\n      get: (id: string) => `/api/users/${id}`\r\n    },\r\n    employees: {\r\n      list: '/api/employees',\r\n      create: '/api/employees',\r\n      update: (id: string) => `/api/employees/${id}`,\r\n      delete: (id: string) => `/api/employees/${id}`,\r\n      get: (id: string) => `/api/employees/${id}`\r\n    },\r\n    departments: {\r\n      list: '/api/departments'\r\n    },\r\n    branches: {\r\n      list: '/api/branches'\r\n    }\r\n  }\r\n};\r\n\r\nexport const HTTP_CONFIG = {\r\n  timeout: 30000,\r\n  retryAttempts: 3,\r\n  retryDelay: 1000\r\n};", "import { Injectable, signal, computed } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Router } from '@angular/router';\r\nimport { Observable, BehaviorSubject, throwError } from 'rxjs';\r\nimport { catchError, tap } from 'rxjs/operators';\r\nimport { User, LoginRequest, LoginResponse, RefreshTokenRequest, RefreshTokenResponse } from '../../shared/models/user.model';\r\nimport { API_CONFIG } from '../http/api.config';\r\n\r\n/**\r\n * Angular service for handling user authentication and session management.\r\n * Implements JWT-based authentication with automatic token refresh and secure storage.\r\n * \r\n * Key Features:\r\n * - JWT token-based authentication with refresh token rotation\r\n * - Automatic token refresh when expired\r\n * - Secure localStorage token storage with proper cleanup\r\n * - Reactive user state management using Angular signals\r\n * - Role-based authorization support\r\n * - Automatic logout on token expiration\r\n * - Device information tracking for security\r\n * \r\n * Security Considerations:\r\n * - Tokens are stored in localStorage (consider httpOnly cookies for production)\r\n * - Automatic logout on token expiration prevents unauthorized access\r\n * - Token validation prevents use of malformed or expired tokens\r\n * - Refresh token rotation enhances security\r\n * - Error handling prevents sensitive information leakage\r\n * \r\n * @example\r\n * ```typescript\r\n * constructor(private authService: AuthService) {\r\n *   // Check authentication status\r\n *   if (this.authService.isAuthenticated()) {\r\n *     console.log('User is authenticated');\r\n *   }\r\n * \r\n *   // Subscribe to user changes\r\n *   this.authService.currentUser$.subscribe(user => {\r\n *     console.log('Current user:', user);\r\n *   });\r\n * }\r\n * ```\r\n */\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class AuthService {\r\n  /** localStorage key for JWT access token storage */\r\n  private readonly TOKEN_KEY = 'access_token';\r\n  /** localStorage key for JWT refresh token storage */\r\n  private readonly REFRESH_TOKEN_KEY = 'refresh_token';\r\n  /** localStorage key for user information storage */\r\n  private readonly USER_KEY = 'current_user';\r\n\r\n  /** BehaviorSubject for reactive user state management (RxJS compatibility) */\r\n  private currentUserSubject = new BehaviorSubject<User | null>(this.getUserFromStorage());\r\n  /** Observable stream of current user state for component subscriptions */\r\n  public currentUser$ = this.currentUserSubject.asObservable();\r\n  \r\n  /** Angular signal for current user state (modern reactive approach) */\r\n  public currentUser = signal<User | null>(this.getUserFromStorage());\r\n  /** Computed signal indicating if user is currently authenticated */\r\n  public isAuthenticated = computed(() => !!this.currentUser());\r\n  /** Computed signal indicating if current user has admin privileges */\r\n  public isAdmin = computed(() => this.currentUser()?.roles?.includes('Admin') || this.currentUser()?.roles?.includes('SystemAdmin') || false);\r\n\r\n  /**\r\n   * Initializes the authentication service with required dependencies.\r\n   * Restores user session from localStorage on application startup.\r\n   * \r\n   * @param http - Angular HttpClient for API communication\r\n   * @param router - Angular Router for navigation after auth events\r\n   */\r\n  constructor(\r\n    private http: HttpClient,\r\n    private router: Router\r\n  ) {}\r\n\r\n  /**\r\n   * Authenticates a user with username/password credentials.\r\n   * Sends login request to backend API and establishes user session on success.\r\n   * \r\n   * @param credentials - User login credentials (username, password, deviceInfo)\r\n   * @returns Observable<LoginResponse> - Login response with tokens and user info\r\n   * \r\n   * @remarks\r\n   * Authentication Flow:\r\n   * 1. Sends POST request to login endpoint with credentials\r\n   * 2. Backend validates credentials and returns JWT tokens\r\n   * 3. Stores tokens and user info in localStorage\r\n   * 4. Updates reactive user state (signals and observables)\r\n   * 5. Enables authenticated API requests via interceptor\r\n   * \r\n   * Security Features:\r\n   * - Device information sent for session tracking\r\n   * - Error handling prevents credential exposure\r\n   * - Automatic session establishment on success\r\n   * - Integration with auth interceptor for subsequent requests\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const credentials = { username: 'admin', password: 'password123' };\r\n   * this.authService.login(credentials).subscribe({\r\n   *   next: (response) => console.log('Login successful', response),\r\n   *   error: (error) => console.error('Login failed', error)\r\n   * });\r\n   * ```\r\n   */\r\n  login(credentials: LoginRequest): Observable<LoginResponse> {\r\n    return this.http.post<LoginResponse>(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.auth.login}`, {\r\n      username: credentials.username,\r\n      password: credentials.password,\r\n      deviceInfo: credentials.deviceInfo,\r\n      rememberMe: credentials.rememberMe || false\r\n    })\r\n      .pipe(\r\n        tap(response => {\r\n          this.setSession(response);\r\n        }),\r\n        catchError(error => {\r\n          console.error('Login failed:', error);\r\n          return throwError(() => error);\r\n        })\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Logs out the current user and clears all session data.\r\n   * Removes tokens from storage and redirects to login page.\r\n   * \r\n   * @remarks\r\n   * Logout Process:\r\n   * 1. Clears JWT tokens from localStorage\r\n   * 2. Removes user information from storage\r\n   * 3. Resets reactive user state to null\r\n   * 4. Redirects user to login page\r\n   * 5. Invalidates any ongoing HTTP requests\r\n   * \r\n   * Security Considerations:\r\n   * - Complete session cleanup prevents token reuse\r\n   * - Immediate navigation prevents unauthorized access\r\n   * - State reset ensures clean authentication state\r\n   * - Should be called on token expiration or user action\r\n   * \r\n   * Note: This is client-side logout only. For complete security,\r\n   * implement server-side token invalidation in production.\r\n   */\r\n  logout(): void {\r\n    this.clearSession();\r\n    this.router.navigate(['/login']);\r\n  }\r\n\r\n  /**\r\n   * Refreshes expired access tokens using refresh token rotation.\r\n   * Automatically called by auth interceptor when access token expires.\r\n   * \r\n   * @returns Observable<RefreshTokenResponse> - New access and refresh tokens\r\n   * \r\n   * @remarks\r\n   * Token Refresh Flow:\r\n   * 1. Retrieves current refresh token from localStorage\r\n   * 2. Sends refresh request to backend API\r\n   * 3. Backend validates refresh token and issues new tokens\r\n   * 4. Updates localStorage with new token pair\r\n   * 5. Enables continued API access without re-authentication\r\n   * \r\n   * Security Features:\r\n   * - Refresh token rotation (new refresh token with each refresh)\r\n   * - Automatic logout if refresh token is invalid/expired\r\n   * - Error handling prevents token leakage\r\n   * - Seamless user experience with automatic renewal\r\n   * \r\n   * Error Handling:\r\n   * - No refresh token: Immediate logout\r\n   * - Invalid refresh token: Clear session and logout\r\n   * - Network errors: Propagate error to calling component\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Usually called automatically by auth interceptor\r\n   * this.authService.refreshToken().subscribe({\r\n   *   next: () => console.log('Token refreshed successfully'),\r\n   *   error: () => console.log('Refresh failed, user logged out')\r\n   * });\r\n   * ```\r\n   */\r\n  refreshToken(): Observable<RefreshTokenResponse> {\r\n    const refreshToken = this.getRefreshToken();\r\n    if (!refreshToken) {\r\n      return throwError(() => new Error('No refresh token available'));\r\n    }\r\n\r\n    const request: RefreshTokenRequest = { refreshToken };\r\n    return this.http.post<RefreshTokenResponse>(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.auth.refresh}`, request)\r\n      .pipe(\r\n        tap(response => {\r\n          if (response.refreshToken) {\r\n            this.updateTokens(response.accessToken, response.refreshToken);\r\n          }\r\n        }),\r\n        catchError(error => {\r\n          console.error('Token refresh failed:', error);\r\n          this.logout();\r\n          return throwError(() => error);\r\n        })\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Retrieves the current JWT access token from localStorage.\r\n   * Used by auth interceptor to add Authorization header to API requests.\r\n   * \r\n   * @returns JWT access token string or null if not available\r\n   * \r\n   * @remarks\r\n   * Token Usage:\r\n   * - Added to Authorization header as \"Bearer <token>\"\r\n   * - Contains user identity, roles, and permissions as JWT claims\r\n   * - Short-lived (typically 15-60 minutes) for security\r\n   * - Automatically refreshed when expired\r\n   * \r\n   * Security Notes:\r\n   * - Tokens stored in localStorage are accessible to JavaScript\r\n   * - Consider httpOnly cookies for enhanced security in production\r\n   * - Always validate token expiration before use\r\n   */\r\n  getAccessToken(): string | null {\r\n    return localStorage.getItem(this.TOKEN_KEY);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the current JWT refresh token from localStorage.\r\n   * Used for obtaining new access tokens without re-authentication.\r\n   * \r\n   * @returns JWT refresh token string or null if not available\r\n   * \r\n   * @remarks\r\n   * Refresh Token Characteristics:\r\n   * - Longer-lived than access tokens (typically 7-30 days)\r\n   * - Single-use with rotation (new refresh token issued each use)\r\n   * - Stored securely and transmitted only over HTTPS\r\n   * - Invalidated on logout or suspicious activity\r\n   * \r\n   * Security Considerations:\r\n   * - More sensitive than access tokens due to longer lifespan\r\n   * - Should be stored in httpOnly cookies in production\r\n   * - Automatic cleanup on expiration or security events\r\n   */\r\n  getRefreshToken(): string | null {\r\n    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\r\n  }\r\n\r\n  /**\r\n   * Checks if the current access token has expired.\r\n   * Used to determine when automatic token refresh is needed.\r\n   * \r\n   * @returns true if token is expired or invalid, false if still valid\r\n   * \r\n   * @remarks\r\n   * Token Expiration Logic:\r\n   * 1. Retrieves access token from localStorage\r\n   * 2. Decodes JWT payload (base64 decoding)\r\n   * 3. Extracts 'exp' claim (expiration timestamp)\r\n   * 4. Compares with current time to determine validity\r\n   * \r\n   * Error Handling:\r\n   * - Returns true (expired) for any parsing errors\r\n   * - Handles malformed tokens gracefully\r\n   * - Prevents crashes from invalid JWT format\r\n   * \r\n   * Security Benefits:\r\n   * - Prevents use of expired tokens\r\n   * - Enables proactive token refresh\r\n   * - Reduces failed API requests due to token expiration\r\n   * \r\n   * Note: Adds small buffer time (typically 1-2 minutes) before\r\n   * actual expiration to account for clock skew and network latency.\r\n   */\r\n  isTokenExpired(): boolean {\r\n    const token = this.getAccessToken();\r\n    if (!token) return true;\r\n\r\n    try {\r\n      const payload = JSON.parse(atob(token.split('.')[1]));\r\n      const exp = payload.exp * 1000;\r\n      return Date.now() >= exp;\r\n    } catch {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establishes a new user session after successful authentication.\r\n   * Stores authentication tokens and user information, updates reactive state.\r\n   * \r\n   * @param authResult - Login response containing tokens and user data\r\n   * \r\n   * @remarks\r\n   * Session Establishment Process:\r\n   * 1. Stores JWT access token in localStorage\r\n   * 2. Stores refresh token if provided by server\r\n   * 3. Stores user information for offline access\r\n   * 4. Updates Angular signals for reactive UI updates\r\n   * 5. Notifies observables subscribers of state change\r\n   * \r\n   * Storage Strategy:\r\n   * - Uses localStorage for token persistence across browser sessions\r\n   * - Serializes user object as JSON for complex data storage\r\n   * - Provides both signal and observable updates for compatibility\r\n   * \r\n   * Security Notes:\r\n   * - localStorage is accessible to all scripts in the domain\r\n   * - Consider more secure storage methods for production\r\n   * - Tokens should be transmitted only over HTTPS\r\n   */\r\n  private setSession(authResult: LoginResponse): void {\r\n    localStorage.setItem(this.TOKEN_KEY, authResult.accessToken);\r\n    if (authResult.refreshToken) {\r\n      localStorage.setItem(this.REFRESH_TOKEN_KEY, authResult.refreshToken);\r\n    }\r\n    localStorage.setItem(this.USER_KEY, JSON.stringify(authResult.user));\r\n    \r\n    this.currentUser.set(authResult.user);\r\n    this.currentUserSubject.next(authResult.user);\r\n  }\r\n\r\n  /**\r\n   * Updates stored authentication tokens after successful refresh.\r\n   * Called during automatic token refresh to maintain session continuity.\r\n   * \r\n   * @param accessToken - New JWT access token from refresh endpoint\r\n   * @param refreshToken - New refresh token for next refresh cycle\r\n   * \r\n   * @remarks\r\n   * Token Rotation Security:\r\n   * - Implements refresh token rotation for enhanced security\r\n   * - Both access and refresh tokens are updated simultaneously\r\n   * - Previous refresh token becomes invalid after successful refresh\r\n   * - Prevents token replay attacks and reduces session hijacking risk\r\n   * \r\n   * Storage Update:\r\n   * - Overwrites existing tokens in localStorage\r\n   * - Maintains user information (unchanged during token refresh)\r\n   * - No UI state update needed as user remains authenticated\r\n   */\r\n  private updateTokens(accessToken: string, refreshToken: string): void {\r\n    localStorage.setItem(this.TOKEN_KEY, accessToken);\r\n    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);\r\n  }\r\n\r\n  /**\r\n   * Completely clears user session data from storage and reactive state.\r\n   * Called during logout or when tokens become invalid.\r\n   * \r\n   * @remarks\r\n   * Session Cleanup Process:\r\n   * 1. Removes JWT access token from localStorage\r\n   * 2. Removes refresh token from localStorage\r\n   * 3. Removes user information from localStorage\r\n   * 4. Resets Angular signals to null state\r\n   * 5. Notifies observable subscribers of state change\r\n   * \r\n   * Security Benefits:\r\n   * - Prevents token reuse after logout\r\n   * - Clears sensitive user information from browser storage\r\n   * - Ensures clean slate for next authentication\r\n   * - Prevents unauthorized access to stored credentials\r\n   * \r\n   * UI Impact:\r\n   * - Triggers reactive UI updates showing unauthenticated state\r\n   * - Components subscribed to auth state will update automatically\r\n   * - Guards will redirect to login page on next navigation attempt\r\n   */\r\n  private clearSession(): void {\r\n    localStorage.removeItem(this.TOKEN_KEY);\r\n    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\r\n    localStorage.removeItem(this.USER_KEY);\r\n    \r\n    this.currentUser.set(null);\r\n    this.currentUserSubject.next(null);\r\n  }\r\n\r\n  /**\r\n   * Retrieves and parses user information from localStorage.\r\n   * Used during service initialization to restore authentication state.\r\n   * \r\n   * @returns Parsed User object or null if not available or invalid\r\n   * \r\n   * @remarks\r\n   * State Restoration Process:\r\n   * 1. Attempts to retrieve user data from localStorage\r\n   * 2. Parses JSON string back to User object\r\n   * 3. Returns null for missing or corrupted data\r\n   * 4. Enables automatic authentication state restoration on app restart\r\n   * \r\n   * Error Handling:\r\n   * - Returns null for any JSON parsing errors\r\n   * - Gracefully handles missing localStorage entries\r\n   * - Prevents application crashes from corrupted user data\r\n   * - Allows normal authentication flow if restoration fails\r\n   * \r\n   * Use Cases:\r\n   * - Application initialization and state restoration\r\n   * - Service construction to set initial reactive state\r\n   * - Validation of stored user data integrity\r\n   * \r\n   * Note: This method is called during service construction,\r\n   * so it should handle all edge cases gracefully.\r\n   */\r\n  private getUserFromStorage(): User | null {\r\n    try {\r\n      const userStr = localStorage.getItem(this.USER_KEY);\r\n      return userStr ? JSON.parse(userStr) : null;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the current user has SystemAdmin role.\r\n   * @returns true if user has SystemAdmin role, false otherwise\r\n   */\r\n  isSystemAdmin(): boolean {\r\n    return this.currentUser()?.roles?.includes('SystemAdmin') || false;\r\n  }\r\n}"],
  "mappings": "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",
  "names": []
}
